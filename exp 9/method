EXP 9 Automate the process of running containerized applications for exercise 7 using Kubernetes.
Absolutely! Letâ€™s start from the very base level â€” as if you have zero knowledge.
By the end, you will clearly understand what â€œcontainerâ€, â€œDockerâ€, â€œKubernetesâ€, and â€œorchestrationâ€ mean â€” in simple words.
________________________________________
ğŸ§  What Is the Problem in the Real World?
Suppose you create a Python app and want to give it to others or deploy it online.
But different computers have:
â€¢	Different versions of Python
â€¢	Different libraries
â€¢	Different settings
â¡ Your app may work on your PC but fail on theirs â†’ â€œWorks on my system!â€ problem.
________________________________________
ğŸ“¦ Solution: Containers (Docker)
A container is like a box that holds:
âœ” Your code
âœ” Required libraries
âœ” Python version
âœ” Perfect environment
So wherever you run this box, your app will always work.
ğŸ‘‰ We use Docker to create this box = Docker Container
________________________________________
ğŸš¢ Docker = Shipping System for Software
â€¢	Docker helps us pack our application into a container
â€¢	We can ship it anywhere â€” cloud, server, other PC
â€¢	It works exactly the same everywhere
âš ï¸ But one problem:
What if we need 10 containers? Or 100? Or restart automatically if they crash?
Docker cannot manage many containers alone.
________________________________________
ğŸ¤– This is where Kubernetes comes in!
Kubernetes = Container Orchestration System
ğŸ“Œ Orchestration = Automatically managing multiple containers
Just like a music orchestra has a conductor who manages all musiciansâ€¦
ğŸ‘‰ Kubernetes is like the conductor that manages all containers!
________________________________________
ğŸ¯ What Kubernetes Can Do (Automatically)
Need	Kubernetes does it
Start containers	âœ” Yes
Restart if crash	âœ” Yes
Create 10 copies	âœ” Yes
Load balance traffic	âœ” Yes
Expose app to users	âœ” Yes
Deploy new version	âœ” Yes
________________________________________
ğŸ“Œ Simple Real-Life Example
Imagine Swiggy or Zomato app:
â€¢	Thousands of users opening it at the same time
â€¢	App must run on many servers & containers
â€¢	If a container crashes â†’ Should restart automatically
â€¢	If more users â†’ Must create MORE containers
ğŸ‘‰ THIS is done by Kubernetes
________________________________________
ğŸ’¡ Main Concepts â€” in Simple Words
Term	Meaning
Container	Box containing app + environment
Docker	Creates/ships containers
Kubernetes	Manages many containers
Pod	Smallest container in Kubernetes
Deployment	Instruction: how many Pods to run
Service	Opens port so user can access app
________________________________________
ğŸ” Our Experiment â€“ What Did We Do?
Step	What We Did	Why?
Write Python app	app.py	Our application
Create Dockerfile	Defined container	Pack environment
Build Docker image	docker build	Created container
Enable Kubernetes	Docker Desktop	Create cluster
Write YAML files	deployment + service	Tell Kubernetes what to do
Apply them	kubectl apply	Deploy app
Access app	via browser	Verify deployment
________________________________________
âš¡ Final Understanding
âœ” Docker = Packs app into containers
âœ” Kubernetes = Manages those containers
âœ” Orchestration = Automatic management of containers
âœ” Purpose = Run apps reliably even in big companies
________________________________________
ğŸŒŸ YOU HAVE ACTUALLY DONE MINI REAL DEVOPS!
You already used:
â€¢	Docker
â€¢	Kubernetes
â€¢	Deployment
â€¢	Services
â€¢	CLI commands
This is same process followed by Amazon, Netflix, Google! ğŸ”¥
________________________________________
Want an experiment report for submission? Or diagram? I can prepare it for you. ğŸ˜Š

which means instead of manually starting containers, Kubernetes will create, manage, scale, and restart them automatically.
Perfect! Letâ€™s do this without Minikube, using Docker Desktopâ€™s built-in Kubernetes (or any other existing K8s cluster). Iâ€™ll give you a step-by-step guide, starting from your C:\kubeapp folder.
________________________________________
Step 0: Prerequisites
1.	Docker Desktop installed â†’ enable Kubernetes in settings:
o	Open Docker Desktop â†’ Settings â†’ Kubernetes â†’ Check Enable Kubernetes â†’ Apply & Restart
o	Wait until Kubernetes shows Running.
2.	kubectl installed â†’ Docker Desktop usually comes with it. Check:
3.	kubectl version --client
4.	Docker Hub account (for pushing images).
________________________________________
Step 1: Flask App
Create app.py in C:\kubeapp:
from flask import Flask
import os

app = Flask(__name__)

@app.route('/')
def hello():
    name = os.getenv('NAME', 'World')
    return f'Hello, {name}!'

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)

Code Part	Meaning (in English)
from flask import Flask	Import Flask framework
import os	Import OS module to read environment variable
app = Flask(__name__)	Create Flask application object
@app.route('/')	Define URL path â€” homepage (/)
def hello():	Function that runs when someone opens /
os.getenv('NAME', 'World')	Get name from environment variable, default = World
return f'Hello, {name}!'	Show output on browser
app.run(host='0.0.0.0', port=80)	Start the web server

Flask is a lightweight Python web framework.
It defines a route (/) and starts a web server.
It uses environment variables for dynamic response.

Create requirements.txt:
flask
________________________________________


Step 2: Dockerfile
In C:\kubeapp:
FROM python:3.9-slim
WORKDIR /app
COPY . /app
RUN pip install --no-cache-dir -r requirements.txt
EXPOSE 80
ENV NAME World
CMD ["python", "app.py"]

Line	Meaning (in normal words)
FROM python:3.9-slim	Use Python base image
WORKDIR /app	Set default folder inside container
COPY . /app	Copy all files into container
RUN pip install ...	Install required Python libraries
EXPOSE 80	Open port 80 for web access
ENV NAME World	Create environment variable
CMD ["python", "app.py"]	Start Python program

Dockerfile creates container image.
It uses a base image, sets working directory, copies files, installs dependencies, exposes port, sets environment variable, and runs the Python file.
________________________________________
Step 3: Build & Test Docker Image Locally
1.	Build the image:
docker build -t my-python-app .
2.	Test locally (optional):
docker run -p 8080:80 my-python-app
Open browser â†’ http://localhost:8080 â†’ Should see Hello, World!
Press Ctrl+C to stop.
â€¢	Then we pushed it to Docker Hub so Kubernetes can access it.
ğŸ‘‰ Why?
Kubernetes only runs Docker containers, so we must provide a ready-made image.
â€¢	Clicked Create cluster / Enable Kubernetes
â€¢	Docker created a single-node Kubernetes cluster on your laptop.
ğŸ‘‰ Why?
Kubernetes needs a cluster to run apps.
________________________________________
Step 4: Push Image to Docker Hub
1.	Login:
docker login
2.	Tag the image:
docker tag my-python-app:latest priyamvadaae4/my-python-app:latest
3.	Push:
docker push priyamvadaae4/my-python-app:latest
________________________________________
Step 5: Kubernetes Deployment
Create deployment.yaml in C:\kubeapp:
Creates PODs (running containers)
ğŸ”¹ Makes sure the app keeps running
ğŸ”¹ Can create multiple copies (replicas)
Code:-
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-python-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-python-app
  template:
    metadata:
      labels:
        app: my-python-app
    spec:
      containers:
      - name: my-python-app
        image: priyamvadaae4/my-python-app:latest
        ports:
        - containerPort: 80
Replace priyamvadaae4 with your Docker Hub username.
________________________________________
Step 6: Kubernetes Service
Create service.yaml:
ğŸ”¹ Exposes the app to users
ğŸ”¹ We used NodePort, so we can access it via:
http://localhost:<port>
ğŸ‘‰ Why?
Kubernetes does not automatically expose apps â€” Service is required.
Code:-
apiVersion: v1
kind: Service
metadata:
  name: my-python-app-service
spec:
  selector:
    app: my-python-app
  ports:
    - port: 80
      targetPort: 80
  type: LoadBalancer
Note: On Docker Desktop, LoadBalancer will work differently â€” you can access the service using localhost with a NodePort automatically assigned.
________________________________________
Step 7: Apply Deployment & Service
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
This is like telling Kubernetes:
â€œHere is my app. Please run it and expose it!â€

Check status:
kubectl get deployments
kubectl get pods   â†’  shows running containers
kubectl get svc    â†’  shows how to access the app________________________________________
Step 8: Access the App
Option 1: Using Service NodePort
1.	Find the NodePort assigned to your service:
kubectl get svc my-python-app-service
or
kubectl get svc my-python-app-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
Youâ€™ll see something like:
NAME	TYPE	CLUSTER-IP	EXTERNAL-IP	PORT(S)
my-python-app-service	LoadBalancer	10.0.0.123		80:31234/TCP
				
2.	Open browser â†’ kubectl edit svc my-python-app-service -> change type using ---------ïƒ  type: NodePort ----> kubectl get svc
3.	http://localhost:31234 (the NodePort)
You should see Hello, World!
